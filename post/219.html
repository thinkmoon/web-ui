<!DOCTYPE html>
<html  data-head-attrs="">

<head >
  <title>在微信小程序里使用async/await异步API及浅谈各种异步 | 指尖魔法屋-醉月思的博客</title><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><script async src="/ads.js" crossorigin="anonymous"></script><meta name="keywords" content="微信小程序"><meta name="description" content="web前端开发工程师、面向高保真编程、总结与记录是两个极其优秀的学习习惯、对知识和技术保持敬畏之心！"><meta name="head:count" content="5"><link rel="modulepreload" href="/nuxt-asset/entry-a0a9c288.mjs" as="script" crossorigin><link rel="preload" href="/nuxt-asset/entry.fedc1be4.css" as="style"><link rel="modulepreload" href="/nuxt-asset/default-10e5eaa9.mjs" as="script" crossorigin><link rel="preload" href="/nuxt-asset/default.86255851.css" as="style"><link rel="modulepreload" href="/nuxt-asset/Footer-3dd58ce4.mjs" as="script" crossorigin><link rel="modulepreload" href="/nuxt-asset/_cid_-518e69bc.mjs" as="script" crossorigin><link rel="modulepreload" href="/nuxt-asset/asyncData-38b92481.mjs" as="script" crossorigin><link rel="prefetch" href="/nuxt-asset/background.36a7be78.jpg"><link rel="prefetch" as="script" href="/nuxt-asset/404-6271d218.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/editor-cb84eaae.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/index-a5a21114.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/post-list-8ebd2004.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/admin-ee186c4f.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/_pageIndex_-8706ad22.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/PostList-cb4d7779.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/index-6b7d0274.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/index-a7781c56.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/login-bf2de25e.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/_pageIndex_-27b7ab33.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/_pageIndex_-4cfc3b71.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/TagApi-0ac04931.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/index-3ceff8c5.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/auth-e1847cfe.mjs"><link rel="prefetch" as="script" href="/nuxt-asset/admin-7dc5992b.mjs"><link rel="stylesheet" href="/nuxt-asset/entry.fedc1be4.css"><link rel="stylesheet" href="/nuxt-asset/default.86255851.css">
</head>

<body  data-head-attrs="">
  <div id="__nuxt"><!--[--><div data-v-062e129b><div class="top-menu" data-v-062e129b data-v-2a7a94f1><div class="left" data-v-2a7a94f1><a class="el-link el-link--default is-underline" href="/" data-v-2a7a94f1><!--v-if--><span class="el-link__inner"><!--[-->指尖魔法屋<!--]--></span><!--v-if--></a></div><span data-v-2a7a94f1></span><div class="right" data-v-2a7a94f1><a class="el-link el-link--default" href="/admin" data-v-2a7a94f1><!--v-if--><span class="el-link__inner"><!--[--><i class="el-icon pointer" style="font-size:26px;" data-v-2a7a94f1><!--[--><svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" data-v-2a7a94f1><path fill="currentColor" d="M512 512a192 192 0 1 0 0-384 192 192 0 0 0 0 384zm0 64a256 256 0 1 1 0-512 256 256 0 0 1 0 512zm320 320v-96a96 96 0 0 0-96-96H288a96 96 0 0 0-96 96v96a32 32 0 1 1-64 0v-96a160 160 0 0 1 160-160h448a160 160 0 0 1 160 160v96a32 32 0 1 1-64 0z"></path></svg><!--]--></i><!--]--></span><!--v-if--></a></div></div><div class="app-container" data-v-062e129b><div class="layout" data-v-062e129b><div class="main-content" data-v-062e129b><!--[--><div class="" data-v-4b611cb2><!----><div class="article-content" data-v-4b611cb2><div class="v-md-editor-preview" style="tab-size:2;" data-v-4b611cb2><div class="github-markdown-body"><h1 data-v-md-heading="在微信小程序里使用async-await异步api及浅谈各种异步" data-v-md-line="1">在微信小程序里使用async/await异步API及浅谈各种异步</h1>
<blockquote data-v-md-line="2">
<p data-v-md-line="2">想达到本文效果，需使用wepy框架。不了解wepy？转<a href="https://tencent.github.io/wepy/index.html" class="custom-external-link" rel="nofollow noopener noreferrer" target="_blank">https://tencent.github.io/wepy/index.html</a></p>
</blockquote>
<h2 data-v-md-heading="什么是async-await" data-v-md-line="3">什么是async/await?</h2>
<blockquote data-v-md-line="4">
<p data-v-md-line="4">在最新的ES7（ES2017）中提出的前端异步特性：async、await。<br>
async顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成。也就是我们平常所说的异步等待。不过需注意<code>await只能在async函数中使用</code>。</p>
</blockquote>
<h2 data-v-md-heading="为什么需要async-await" data-v-md-line="7">为什么需要async/await?</h2>
<p data-v-md-line="8">在async/await之前，我们有三种方式写异步代码</p>
<h3 data-v-md-heading="_1-嵌套回调" data-v-md-line="9">1. 嵌套回调</h3>
<p data-v-md-line="10">其中思想就是,a函数执行完了得到的结果后在执行b。<br>
形如</p>
<div data-v-md-line="12"><div class="v-md-pre-wrapper v-md-pre-wrapper-javascript extra-class"><pre class="v-md-hljs-javascript"><code>wx.getSetting({
      <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span> {
        <span class="hljs-built_in">console</span>.log(res.authSetting[<span class="hljs-string">&#x27;scope.userLocation&#x27;</span>]);
        <span class="hljs-keyword">if</span> (!res.authSetting[<span class="hljs-string">&#x27;scope.userLocation&#x27;</span>]) {
          wx.authorize({
            <span class="hljs-attr">scope</span>: <span class="hljs-string">&#x27;scope.userLocation&#x27;</span>,
            <span class="hljs-function"><span class="hljs-title">fail</span>(<span class="hljs-params">res</span>)</span> {
              Toast(<span class="hljs-string">&#x27;无法获取位置,采用默认排序&#x27;</span>);
            }
          });
        } <span class="hljs-keyword">else</span> {
          wx.getLocation({
            <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;wgs84&#x27;</span>,
            <span class="hljs-function"><span class="hljs-title">success</span>(<span class="hljs-params">res</span>)</span> {
              _this.setData({ <span class="hljs-attr">location</span>: res });
              <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;您的位置信息:&#x27;</span>, res);
            },
            <span class="hljs-function"><span class="hljs-title">fail</span>(<span class="hljs-params"></span>)</span> {
              Toast(<span class="hljs-string">&#x27;无法获取位置,采用默认排序&#x27;</span>);
            }
          });
        }
      }
    });
</code></pre>
</div></div><blockquote data-v-md-line="38">
<p data-v-md-line="38">上面的代码你不用看，就会感觉。这啥东西？乱七八糟的。这就是嵌套回调。很不巧，原生微信小程序开发就是这样的。</p>
</blockquote>
<h3 data-v-md-heading="_2-以promise为主的链式回调" data-v-md-line="40">2. 以Promise为主的链式回调</h3>
<blockquote data-v-md-line="41">
<p data-v-md-line="41">所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。形如</p>
</blockquote>
<div data-v-md-line="42"><div class="v-md-pre-wrapper v-md-pre-wrapper-javascript extra-class"><pre class="v-md-hljs-javascript"><code><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> {
 <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;done&#x27;</span>);
 })
p1.then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>{
 <span class="hljs-built_in">console</span>.log(data); <span class="hljs-comment">// done</span>
})
</code></pre>
</div></div><p data-v-md-line="50">如果你的函数够多的话，那么就会一直then()下去。</p>
<blockquote data-v-md-line="51">
<p data-v-md-line="51">为了优雅，Promise提供了一个方法<code>Promise.all([p1,p2,p3])</code> ，用于将多个Promise实例，包装成一个新的Promise实例。接收的参数是一个数组,p1、p2、p3都是Promise对象<br>
分两种情况：</p>
</blockquote>
<ol data-v-md-line="53">
<li>p1、p2、p3的状态都是resolve的时候，Promise.all的状态才会变成resolve；</li>
<li>只要p1、p2、p3中有一个的状态为reject，那么Promise.all的状态就会变成reject；<br>
所以我们可以用Promise.all()来解决多个异步依赖调用。</li>
</ol>
<h3 data-v-md-heading="_3-使用generators" data-v-md-line="57">3. 使用Generators</h3>
<div data-v-md-line="58"><div class="v-md-pre-wrapper v-md-pre-wrapper-javascript extra-class"><pre class="v-md-hljs-javascript"><code><span class="hljs-function"><span class="hljs-keyword">function</span> *<span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">var</span> x = <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
    <span class="hljs-keyword">var</span> y = <span class="hljs-keyword">yield</span> x;
    <span class="hljs-keyword">var</span> z = <span class="hljs-keyword">yield</span> (y * <span class="hljs-number">2</span>);
}
</code></pre>
</div></div><blockquote data-v-md-line="65">
<p data-v-md-line="65">上面代码中的每一条语句都会按顺序一个一个地执行。Yield关键字标明了代码中被阻塞的点（只能被generator函数自己阻塞，外部代码不能阻塞generator函数的执行），但是不会改变*main()函数中代码的执行顺序。这段代码很简单！</p>
</blockquote>
<p data-v-md-line="67">但是，这三种写起来都还是不够优雅，ES7做了优化改进，async/await应运而生，async/await相比较Promise 对象then 函数的嵌套，与 Generator 执行的繁琐(需要借助co才能自动执行，否则得手动调用next())， Async/Await 可以让你轻松写出同步风格的代码同时又拥有异步机制，更加简洁，逻辑更加清晰。</p>
<blockquote data-v-md-line="69">
<p data-v-md-line="69">示例</p>
</blockquote>
<div data-v-md-line="70"><div class="v-md-pre-wrapper v-md-pre-wrapper-javascript extra-class"><pre class="v-md-hljs-javascript"><code><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>{};
<span class="hljs-keyword">const</span> b = <span class="hljs-keyword">await</span> a();
</code></pre>
</div></div><h2 data-v-md-heading="这样做的好处" data-v-md-line="75">这样做的好处？</h2>
<blockquote data-v-md-line="76">
<p data-v-md-line="76">唔，你不觉得一个优雅的代码就该是这样吗？好吧，其实这样更容易符合我们平常的思维逻辑</p>
</blockquote>
<h2 data-v-md-heading="回到本文的题目" data-v-md-line="78">回到本文的题目</h2>
<blockquote data-v-md-line="79">
<p data-v-md-line="79">在wepy1.4.1以后的版本（之前的版本都是默认开启的），默认不支持async/await，需要用户手动加入，方法如下：</p>
</blockquote>
<h3 data-v-md-heading="进入项目根目录-安装runtime包" data-v-md-line="80">进入项目根目录，安装runtime包</h3>
<div data-v-md-line="81"><div class="v-md-pre-wrapper v-md-pre-wrapper- extra-class"><pre class="v-md-hljs-"><code>npm install wepy-async-function --save
</code></pre>
</div></div><h3 data-v-md-heading="修改wepy-config-js加入runtime配置" data-v-md-line="84">修改wepy.config.js加入runtime配置</h3>
<div data-v-md-line="85"><div class="v-md-pre-wrapper v-md-pre-wrapper- extra-class"><pre class="v-md-hljs-"><code>        babel: {
            &quot;presets&quot;: [
                &quot;env&quot;
            ],
            &quot;plugins&quot;: [
                &quot;transform-export-extensions&quot;,
                &quot;syntax-export-extensions&quot;
            ]
        }
</code></pre>
</div></div><h3 data-v-md-heading="在app-wpy中引入引入runtime包" data-v-md-line="96">在app.wpy中引入引入runtime包</h3>
<div data-v-md-line="97"><div class="v-md-pre-wrapper v-md-pre-wrapper- extra-class"><pre class="v-md-hljs-"><code>import 'wepy-async-function'; 
</code></pre>
</div></div><h3 data-v-md-heading="在app-wpy中使api-promise化" data-v-md-line="100">在app.wpy中使API promise化</h3>
<blockquote data-v-md-line="101">
<p data-v-md-line="101">重写构造函数，使其支持async/await。</p>
</blockquote>
<div data-v-md-line="102"><div class="v-md-pre-wrapper v-md-pre-wrapper- extra-class"><pre class="v-md-hljs-"><code>export default class extends wepy.app {
    constructor () {
        super();
        this.use('promisify');
    }
}
</code></pre>
</div></div><h3 data-v-md-heading="重启编译" data-v-md-line="110">重启编译</h3>
<div data-v-md-line="111"><div class="v-md-pre-wrapper v-md-pre-wrapper- extra-class"><pre class="v-md-hljs-"><code>wepy build --no-cache
</code></pre>
</div></div><h2 data-v-md-heading="使用示例" data-v-md-line="115">使用示例</h2>
<blockquote data-v-md-line="116">
<p data-v-md-line="116">在wepy框架官方文档中已说明，对所有的微信小程序都支持async/await操作。只需将形如<code>wx.getuserInfo</code>改写为<code>wepy.getuserInfo</code>即可</p>
</blockquote>
<div data-v-md-line="117"><div class="v-md-pre-wrapper v-md-pre-wrapper- extra-class"><pre class="v-md-hljs-"><code>async userInfoAsync() {
    const _this = this;
    const data = await wepy.getSetting(); //获取设置数据
    if (data.authSetting['scope.userInfo']) { //判断是否有获取用户信息的权限
      await wepy.login(); //登录
      let data = await wepy.getUserInfo();//获取用户信息
      _this.userInfo = data.userInfo;//采用wepy框架修改过后的功能，支持直接赋值数据绑定
      _this.$apply(); //在async的函数中，必须主动执行`$apply()`来进行脏数据检查
    }
  }
async onShow() {
    this.userInfoAsync(); //调用async函数
  }
</code></pre>
</div></div><blockquote data-v-md-line="132">
<p data-v-md-line="132">以上代码实现了异步同步用户userInfo的功能</p>
</blockquote>
<p data-v-md-line="134">参考文献:</p>
<ol data-v-md-line="135">
<li><a href="https://www.jb51.net/article/103068.htm" class="custom-external-link" rel="nofollow noopener noreferrer" target="_blank">使用Promise链式调用解决多个异步回调的问题</a></li>
<li><a href="https://blog.csdn.net/samt007/article/details/54647361" class="custom-external-link" rel="nofollow noopener noreferrer" target="_blank">关于js的callback回调函数以及嵌套回调函数的执行过程理解</a></li>
<li><a href="https://www.cnblogs.com/jaxu/p/6592210.html" class="custom-external-link" rel="nofollow noopener noreferrer" target="_blank">ES6 Generators并发</a></li>
<li><a href="https://www.cnblogs.com/leungUwah/p/7932912.html" class="custom-external-link" rel="nofollow noopener noreferrer" target="_blank">ES7前端异步玩法：async/await理解</a></li>
<li><a href="https://segmentfault.com/a/1190000007535316?utm_source=tag-newest" class="custom-external-link" rel="nofollow noopener noreferrer" target="_blank">理解 JavaScript 的 async/await</a></li>
<li><a href="https://segmentfault.com/a/1190000013292562?utm_source=channel-newest" class="custom-external-link" rel="nofollow noopener noreferrer" target="_blank">Async/await学习</a></li>
<li><a href="https://www.jianshu.com/p/1e75bd387aa0" class="custom-external-link" rel="nofollow noopener noreferrer" target="_blank">浅谈async/await</a></li>
<li><a href="https://github.com/Tencent/wepy/wiki/wepy%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8async-await" class="custom-external-link" rel="nofollow noopener noreferrer" target="_blank">wepy项目中使用async await</a></li>
</ol>
<blockquote data-v-md-line="143">
<p data-v-md-line="143">版权声明: 本文首发于<a href="https://www.thinkmoon.cn/post/219" class="custom-internal-link" target="_blank">指尖魔法屋-在微信小程序里使用async/await异步API及浅谈各种异步</a>,转载或引用必须申明原指尖魔法屋来源及源地址！</p>
</blockquote>
</div></div><ins class="adsbygoogle" data-ad-client="ca-pub-3208634444966567" data-ad-format="fluid" data-ad-layout="in-article" data-ad-slot="2621880404" style="display:block;text-align:center;width:100%;" data-v-4b611cb2></ins></div></div><!--]--></div><div class="page-section" data-v-062e129b><div class="section" data-v-062e129b><div class="el-input el-input-group el-input-group--append input-with-select" style=""><!-- input --><!--[--><!-- prepend slot --><!--v-if--><div class="el-input__wrapper"><!-- prefix slot --><!--v-if--><input class="el-input__inner" type="text" autocomplete="off" tabindex="0" placeholder="站内搜索" style=""><!-- suffix slot --><!--v-if--></div><!-- append slot --><div class="el-input-group__append"><!--[--><button class="el-button" aria-disabled="false" type="button" style=""><i class="el-icon" style=""><!--[--><svg viewbox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="m795.904 750.72 124.992 124.928a32 32 0 0 1-45.248 45.248L750.656 795.904a416 416 0 1 1 45.248-45.248zM480 832a352 352 0 1 0 0-704 352 352 0 0 0 0 704z"></path></svg><!--]--></i><!--v-if--></button><!--]--></div><!--]--></div></div><div class="section" data-v-062e129b><ins class="adsbygoogle" data-ad-client="ca-pub-3208634444966567" data-ad-format="auto" data-ad-slot="2184618903" data-full-width-responsive="true" style="display:block;"></ins></div></div></div></div><span data-v-062e129b></span></div><div class="footer" data-v-062e129b data-v-68ae0dac><span data-v-68ae0dac>Copyright © 2017-2022 指尖魔法屋. All rights reserved</span><span data-v-68ae0dac>POWERED BY thinkBlog · v0.1.7 · build-20220610</span><span data-v-68ae0dac>网站持续搭建中，感谢关注</span><span data-v-68ae0dac>本站已顽强运行：蛮久了~</span><div data-v-68ae0dac><a class="el-link el-link--primary is-underline" href="http://beian.miit.gov.cn/" data-v-68ae0dac><!--v-if--><span class="el-link__inner"><!--[--> 粤ICP备17055617号 <!--]--></span><!--v-if--></a></div></div><!--]--></div><script>window.__NUXT__=(function(a){return {data:{pinia:{},article:{cid:219,title:"在微信小程序里使用async\u002Fawait异步API及浅谈各种异步",created:1551844440,modified:1551858397,text:"\u003E 想达到本文效果，需使用wepy框架。不了解wepy？转[https:\u002F\u002Ftencent.github.io\u002Fwepy\u002Findex.html](https:\u002F\u002Ftencent.github.io\u002Fwepy\u002Findex.html)\r\n## 什么是async\u002Fawait?\r\n\u003E 在最新的ES7（ES2017）中提出的前端异步特性：async、await。\r\nasync顾名思义是“异步”的意思，async用于声明一个函数是异步的。而await从字面意思上是“等待”的意思，就是用于等待异步完成。也就是我们平常所说的异步等待。不过需注意`await只能在async函数中使用`。\r\n\r\n## 为什么需要async\u002Fawait?\r\n在async\u002Fawait之前，我们有三种方式写异步代码\r\n### 1. 嵌套回调\r\n其中思想就是,a函数执行完了得到的结果后在执行b。\r\n形如\r\n```javascript\r\nwx.getSetting({\r\n      success(res) {\r\n        console.log(res.authSetting['scope.userLocation']);\r\n        if (!res.authSetting['scope.userLocation']) {\r\n          wx.authorize({\r\n            scope: 'scope.userLocation',\r\n            fail(res) {\r\n              Toast('无法获取位置,采用默认排序');\r\n            }\r\n          });\r\n        } else {\r\n          wx.getLocation({\r\n            type: 'wgs84',\r\n            success(res) {\r\n              _this.setData({ location: res });\r\n              console.log('您的位置信息:', res);\r\n            },\r\n            fail() {\r\n              Toast('无法获取位置,采用默认排序');\r\n            }\r\n          });\r\n        }\r\n      }\r\n    });\r\n```\r\n\u003E 上面的代码你不用看，就会感觉。这啥东西？乱七八糟的。这就是嵌套回调。很不巧，原生微信小程序开发就是这样的。\r\n\r\n### 2. 以Promise为主的链式回调\r\n\u003E 所谓Promise，简单来说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。形如\r\n```javascript\r\nvar p1 = new Promise((resolve, reject) =\u003E {\r\n setTimeout(resolve, 1000, 'done');\r\n })\r\np1.then(data=\u003E{\r\n console.log(data); \u002F\u002F done\r\n})\r\n```\r\n如果你的函数够多的话，那么就会一直then()下去。\r\n\u003E为了优雅，Promise提供了一个方法`Promise.all([p1,p2,p3])` ，用于将多个Promise实例，包装成一个新的Promise实例。接收的参数是一个数组,p1、p2、p3都是Promise对象\r\n分两种情况：\r\n1. p1、p2、p3的状态都是resolve的时候，Promise.all的状态才会变成resolve；\r\n2. 只要p1、p2、p3中有一个的状态为reject，那么Promise.all的状态就会变成reject；\r\n所以我们可以用Promise.all()来解决多个异步依赖调用。\r\n\r\n### 3. 使用Generators\r\n```javascript\r\nfunction *main() {\r\n    var x = yield 1;\r\n    var y = yield x;\r\n    var z = yield (y * 2);\r\n}\r\n```\r\n\u003E 上面代码中的每一条语句都会按顺序一个一个地执行。Yield关键字标明了代码中被阻塞的点（只能被generator函数自己阻塞，外部代码不能阻塞generator函数的执行），但是不会改变*main()函数中代码的执行顺序。这段代码很简单！\r\n\r\n但是，这三种写起来都还是不够优雅，ES7做了优化改进，async\u002Fawait应运而生，async\u002Fawait相比较Promise 对象then 函数的嵌套，与 Generator 执行的繁琐(需要借助co才能自动执行，否则得手动调用next())， Async\u002FAwait 可以让你轻松写出同步风格的代码同时又拥有异步机制，更加简洁，逻辑更加清晰。\r\n\r\n\u003E 示例\r\n```javascript\r\nasync a(){};\r\nconst b = await a();\r\n```\r\n\r\n## 这样做的好处？\r\n\u003E 唔，你不觉得一个优雅的代码就该是这样吗？好吧，其实这样更容易符合我们平常的思维逻辑\r\n\r\n## 回到本文的题目\r\n\u003E 在wepy1.4.1以后的版本（之前的版本都是默认开启的），默认不支持async\u002Fawait，需要用户手动加入，方法如下：\r\n### 进入项目根目录，安装runtime包\r\n```\r\nnpm install wepy-async-function --save\r\n```\r\n### 修改wepy.config.js加入runtime配置\r\n```\r\n        babel: {\r\n            \"presets\": [\r\n                \"env\"\r\n            ],\r\n            \"plugins\": [\r\n                \"transform-export-extensions\",\r\n                \"syntax-export-extensions\"\r\n            ]\r\n        }\r\n```\r\n### 在app.wpy中引入引入runtime包\r\n```\r\nimport 'wepy-async-function'; \r\n```\r\n### 在app.wpy中使API promise化\r\n\u003E 重写构造函数，使其支持async\u002Fawait。\r\n```\r\nexport default class extends wepy.app {\r\n    constructor () {\r\n        super();\r\n        this.use('promisify');\r\n    }\r\n}\r\n```\r\n### 重启编译\r\n```\r\nwepy build --no-cache\r\n```\r\n\r\n## 使用示例\r\n\u003E 在wepy框架官方文档中已说明，对所有的微信小程序都支持async\u002Fawait操作。只需将形如`wx.getuserInfo`改写为`wepy.getuserInfo`即可\r\n```\r\nasync userInfoAsync() {\r\n    const _this = this;\r\n    const data = await wepy.getSetting(); \u002F\u002F获取设置数据\r\n    if (data.authSetting['scope.userInfo']) { \u002F\u002F判断是否有获取用户信息的权限\r\n      await wepy.login(); \u002F\u002F登录\r\n      let data = await wepy.getUserInfo();\u002F\u002F获取用户信息\r\n      _this.userInfo = data.userInfo;\u002F\u002F采用wepy框架修改过后的功能，支持直接赋值数据绑定\r\n      _this.$apply(); \u002F\u002F在async的函数中，必须主动执行`$apply()`来进行脏数据检查\r\n    }\r\n  }\r\nasync onShow() {\r\n    this.userInfoAsync(); \u002F\u002F调用async函数\r\n  }\r\n```\r\n\u003E 以上代码实现了异步同步用户userInfo的功能\r\n\r\n参考文献:\r\n1. [使用Promise链式调用解决多个异步回调的问题](https:\u002F\u002Fwww.jb51.net\u002Farticle\u002F103068.htm)\r\n2. [关于js的callback回调函数以及嵌套回调函数的执行过程理解](https:\u002F\u002Fblog.csdn.net\u002Fsamt007\u002Farticle\u002Fdetails\u002F54647361)\r\n3. [ES6 Generators并发](https:\u002F\u002Fwww.cnblogs.com\u002Fjaxu\u002Fp\u002F6592210.html)\r\n4. [ES7前端异步玩法：async\u002Fawait理解](https:\u002F\u002Fwww.cnblogs.com\u002FleungUwah\u002Fp\u002F7932912.html)\r\n5. [理解 JavaScript 的 async\u002Fawait](https:\u002F\u002Fsegmentfault.com\u002Fa\u002F1190000007535316?utm_source=tag-newest)\r\n6. [Async\u002Fawait学习](https:\u002F\u002Fsegmentfault.com\u002Fa\u002F1190000013292562?utm_source=channel-newest)\r\n7. [浅谈async\u002Fawait](https:\u002F\u002Fwww.jianshu.com\u002Fp\u002F1e75bd387aa0)\r\n8. [wepy项目中使用async await](https:\u002F\u002Fgithub.com\u002FTencent\u002Fwepy\u002Fwiki\u002Fwepy%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8async-await)",authorId:a,comments:a,views:2893,likes:1,tag:[{tid:18,name:"微信小程序",order:a,count:a}],category:"教程分享",category_id:14,fields:{}}},state:{error:null},_errors:{},serverRendered:true,config:{public:{TITLE:"指尖魔法屋-醉月思的博客",VERSION:"0.1.7 · build-20220610",KEYWORDS:["thinkmoon","指尖魔法屋","醉月思的博客"],DESCRIPTION:"web前端开发工程师、面向高保真编程、总结与记录是两个极其优秀的学习习惯、对知识和技术保持敬畏之心！",baseUrl:"https:\u002F\u002Fservice.thinkmoon.cn\u002Fapi"},app:{baseURL:"\u002F",buildAssetsDir:"\u002Fnuxt-asset\u002F",cdnURL:""}}}}(0))</script><script type="module" src="/nuxt-asset/entry-a0a9c288.mjs" crossorigin></script><script type="module" src="/nuxt-asset/default-10e5eaa9.mjs" crossorigin></script><script type="module" src="/nuxt-asset/_cid_-518e69bc.mjs" crossorigin></script>
</body>

</html>